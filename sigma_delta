#!/usr/bin/perl -ws

# This software is released into the public domain.
# You can do whatever you want with this code.

#use Data::Dump 'pp';
#$Data::Dump::LINEWIDTH = 80;

our ($h,$help,$stat,$ext);

if ($h || $help) {
  (my $program = $0) =~ s/^.*[\/\\]//;
  print <<HELP;

Calibration of NMR chemical shifts calculation method with ORCA using 
experimental shifts and geometries of a test set of molecules.
Inspired by http://cheshirenmr.info/index.htm.

Usage: $program experimental_shifts.txt 'outs_dir' > method_sigma-delta.dat

The experimental_shifts.txt file contains information on the experimental 
chemical shifts for a set of molecules, along with the corresponding atom 
numbers in the calculated files. Data for 80 small molecules (Tantillo's Test 
Set) from http://cheshirenmr.info/AssociatedContent/Template.xls 
is provided in the ASCII files 1H_exp.txt and 13C_exp.txt located in the 
Tantillo_Test_set directory. The format of the experimental_shifts.txt file 
is described below.

The outs_dir directory must contain the ORCA output files with the 
chemical shift calculations. It must include all filenames mentioned in 
experimental_shifts.txt. The default file extension is .out, but a different 
one can be specified using the -ext=.extension option.

The geometries for the molecules from Tantillo's test set in XYZ format, 
optimized at the PBE0-D3/def2-TZVP/CPCM(Chloroform) level, are provided in the 
Tantillo_Test_set directory. Generating ORCA input files from these is 
straightforward and can also be done using the script:
../make_inp -method='functional basis' [-solv=CPCM_solvent] *.xyz
This script will create a directory named functional_basis_solvent 
and place the input files there.

The program prints to the console a table, formatted for easy import into Excel,
containing 4 columns:
 1. Calculated isotropic shielding constants (sigma)
 2. Experimental chemical shifts (delta)
 3. Molecule name
 4. The atom(s) to which the chemical shift corresponds

With the -stat option, only the statistics for the equations 
delta = slope*sigma + intercept and delta = reference - sigma are printed.
Please note: the first equation is not the same as the one used by Tantillo 
(his is delta = (sigma - intercept)/slope ).

Format of the experimental_shifts.txt file:
  Empty lines and lines starting with # are ignored.
  There are several lines for each molecule.
  The first line is molecule_name. It must start in the first column.
  The outs_dir directory must contain a file molecule_name.out 
  with the NMR shieldings calculation.
  Each subsequent line must start with a space or tab and contain two fields.
  The first field is the atom number in the output file (starting from 1), 
  or a comma-separated list of atom numbers for which shifts should be averaged. 
  A range of numbers can be specified using a hyphen.
  The second field is the experimental chemical shift (ppm).
Example:
Norbornadiene
	1	75.20
	2,3	50.30
	4-7	143.20
HELP
  exit;
}

$ext ||= '.out';

my ($exp_shifts, $out_dir) = @ARGV;
my %delta;
open L, '<', $exp_shifts or die "Can't open $exp_shifts: $!\n";
my $key;
while (<L>) {
  chomp;
  next if m/^\s*$/;
  next if m/^\s*#/;
  if (m/^\w/) {
    $key = $_;
    $key =~ s/\s+$//;
    die "No $out_dir/$key.out file\n" if ! -e "$out_dir/$key.out"; 
  }
  else {
    my ($at,$ppm) = split;
    die "Bad atom numbers for $key\n" if $at !~ /[\d,-]+/;
    die "Bad shift for $key\n" if $ppm !~ /-?\d+(\.\d+)?/;
    push @{$delta{$key}}, [[parse_n($at)], $ppm];
  }
}
close L;
#pp %delta;
#pp $delta{Acetone}; exit;

my $maxl = 0;
foreach (keys %delta) {
  my $l = length $_;
  $maxl = $l if $maxl < $l;
}
#$maxl += 2;

my @out;
foreach my $key (sort keys %delta) {
  my @delta = @{$delta{$key}};
  my @sigma = parse_out_ORCA("$out_dir/$key$ext");
#  warn "----------$key----------\n";
#  pp @delta;
#  pp @sigma;
  foreach (@delta) {
    my ($av,$ppm) = @$_;
    my ($sum, $count,@atoms);
    foreach my $at (@$av) {
      $sum += $sigma[$at][1];
      push @atoms, "$sigma[$at][0]$at";
      $count++;
    }
    my $atoms = join ',', @atoms;
    my $av_sigma = $sum/$count;
    printf "%-8.3f %8.2f     %-${maxl}s  %s\n", $av_sigma, $ppm, $key, $atoms if ! $stat;
    #           sigma_calc delta_exp mol_name atoms
    push @out, [$av_sigma, $ppm,     $key,    $atoms];
  }
}

########## Statistics ###########
if ($stat) {
  my ($X,$Y);
  foreach (@out) {
    push @$X, $_->[0];
    push @$Y, $_->[1];
  }

  print "\n";
  print_in_frame("delta = slope*sigma + intercept\n");
  my $slope = slope($X,$Y);
  my $intercept = intercept($X,$Y);
  my $R2 = correlation($X,$Y)**2;
  my $RMSD;
  for (my $i=0; $i<@$X; $i++) {
    $RMSD += ($Y->[$i] - $slope*$X->[$i]-$intercept)**2;
  }
  $RMSD = sqrt($RMSD/(@$X-1));
  printf "slope %.5f   intercept %.3f\n", $slope, $intercept;
  printf "R^2 %.5f   RMSD %.3f\n", $R2, $RMSD;

  print "\n";
  print_in_frame("delta = reference - sigma\n");
  my $ref;
  for ($i=0; $i<@$X; $i++) {
    $ref += $X->[$i]+$Y->[$i];
  }
  $ref /= @$X-1;
  undef $RMSD;
  for (my $i=0; $i<@$X; $i++) {
    $RMSD += ($Y->[$i] - $ref + $X->[$i])**2;
  }
  $RMSD = sqrt($RMSD/(@$X-1));
  printf "reference %.3f   RMSD %.3f\n", $ref, $RMSD;
  print "\n";
}

sub print_in_frame {
  my $str = shift;
  chomp $str; $str =~ s/^\s+//; $str =~ s/\s+$//;
  my $l = length $str;
  print '-'x($l+4),"\n";
  print "| $str |\n";
  print '-'x($l+4),"\n";
}


sub slope {
  my @X = @{$_[0]};
  my @Y = @{$_[1]};
  return undef if @X<2;
  return undef if @X != @Y;
  return covariance(@_)/(stddev(@X)**2);
}
sub intercept {
  my @X = @{$_[0]};
  my @Y = @{$_[1]};
  return undef if @X<2;
  return undef if @X != @Y;
  return mean(@Y)-slope(@_)*mean(@X);
}
sub sum {
  my $sum;
  foreach my $val (@_) {
    $sum += $val;
  }
  return $sum;
}
sub mean {
  return undef unless @_;
  return sum(@_)/@_;
}
sub stddev {
  return undef if @_<2;
  my $mean = mean(@_);
  my $sum = 0;
  foreach my $val (@_) {
    $sum += ($val-$mean)**2;
  }
  return sqrt($sum/$#_);
}
sub covariance {
  my @X = @{$_[0]};
  my @Y = @{$_[1]};
  return undef if @X<2;
  return undef if @X != @Y;
  my $meanX = mean(@X);
  my $meanY = mean(@Y);
  my $sum = 0;
  for (my $i=0; $i<@X; $i++) {
    $sum += ($X[$i]-$meanX)*($Y[$i]-$meanY);
  }
  return $sum/$#X;
}
sub correlation {
  my @X = @{$_[0]};
  my @Y = @{$_[1]};
  return undef if @X<2;
  return undef if @X != @Y;
  return covariance(@_)/(stddev(@X)*stddev(@Y));
}


sub parse_out_ORCA {
 #Take out filename.
 #Return array of Isotropic CHEMICAL SHIELDINGs
  my $file = shift;
  my @arr;
  open L, '<', $file or die "Can't open $file: $!\n";
  while (<L>) {
    if (m/Nucleus  Element    Isotropic     Anisotropy/) {
      <L>;
      while (<L>) {
        last if m/^\s*$/;
        my ($at,$element,$iso) = split;
        $arr[$at+1] = [$element,$iso];
      }
    }
  }
  close L;
  return @arr;
}


sub parse_n {
  my $n = shift;
  my @vector;
  foreach (split /,/, $n) {
    if (/(\d+)-(\d+)/) { # Раскрываем интервалы (i-n)
		  my @a = $1<=$2 ? $1..$2 : reverse $2..$1;
		  push @vector, @a;
	  }
    else {push @vector, $_}
  } 
  return @vector;
}
